"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-error-boundary";
exports.ids = ["vendor-chunks/react-error-boundary"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-error-boundary/dist/react-error-boundary.development.js":
/*!************************************************************************************!*\
  !*** ./node_modules/react-error-boundary/dist/react-error-boundary.development.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorBoundary: () => (/* binding */ ErrorBoundary),\n/* harmony export */   ErrorBoundaryContext: () => (/* binding */ ErrorBoundaryContext),\n/* harmony export */   useErrorBoundary: () => (/* binding */ useErrorBoundary),\n/* harmony export */   withErrorBoundary: () => (/* binding */ withErrorBoundary)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ ErrorBoundary,ErrorBoundaryContext,useErrorBoundary,withErrorBoundary auto */ \nconst ErrorBoundaryContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst initialState = {\n    didCatch: false,\n    error: null\n};\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n        this.state = initialState;\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            didCatch: true,\n            error\n        };\n    }\n    resetErrorBoundary() {\n        const { error } = this.state;\n        if (error !== null) {\n            var _this$props$onReset, _this$props;\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {\n                args,\n                reason: \"imperative-api\"\n            });\n            this.setState(initialState);\n        }\n    }\n    componentDidCatch(error, info) {\n        var _this$props$onError, _this$props2;\n        (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        const { didCatch } = this.state;\n        const { resetKeys } = this.props;\n        // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n        // we'd end up resetting the error boundary immediately.\n        // This would likely trigger a second error to be thrown.\n        // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n        if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n            var _this$props$onReset2, _this$props3;\n            (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {\n                next: resetKeys,\n                prev: prevProps.resetKeys,\n                reason: \"keys\"\n            });\n            this.setState(initialState);\n        }\n    }\n    render() {\n        const { children, fallbackRender, FallbackComponent, fallback } = this.props;\n        const { didCatch, error } = this.state;\n        let childToRender = children;\n        if (didCatch) {\n            const props = {\n                error,\n                resetErrorBoundary: this.resetErrorBoundary\n            };\n            if (typeof fallbackRender === \"function\") {\n                childToRender = fallbackRender(props);\n            } else if (FallbackComponent) {\n                childToRender = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FallbackComponent, props);\n            } else if (fallback !== undefined) {\n                childToRender = fallback;\n            } else {\n                {\n                    console.error(\"react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop\");\n                }\n                throw error;\n            }\n        }\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ErrorBoundaryContext.Provider, {\n            value: {\n                didCatch,\n                error,\n                resetErrorBoundary: this.resetErrorBoundary\n            }\n        }, childToRender);\n    }\n}\nfunction hasArrayChanged() {\n    let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return a.length !== b.length || a.some((item, index)=>!Object.is(item, b[index]));\n}\nfunction assertErrorBoundaryContext(value) {\n    if (value == null || typeof value.didCatch !== \"boolean\" || typeof value.resetErrorBoundary !== \"function\") {\n        throw new Error(\"ErrorBoundaryContext not found\");\n    }\n}\nfunction useErrorBoundary() {\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ErrorBoundaryContext);\n    assertErrorBoundaryContext(context);\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        error: null,\n        hasError: false\n    });\n    const memoized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useErrorBoundary.useMemo[memoized]\": ()=>({\n                resetBoundary: ({\n                    \"useErrorBoundary.useMemo[memoized]\": ()=>{\n                        context.resetErrorBoundary();\n                        setState({\n                            error: null,\n                            hasError: false\n                        });\n                    }\n                })[\"useErrorBoundary.useMemo[memoized]\"],\n                showBoundary: ({\n                    \"useErrorBoundary.useMemo[memoized]\": (error)=>setState({\n                            error,\n                            hasError: true\n                        })\n                })[\"useErrorBoundary.useMemo[memoized]\"]\n            })\n    }[\"useErrorBoundary.useMemo[memoized]\"], [\n        context.resetErrorBoundary\n    ]);\n    if (state.hasError) {\n        throw state.error;\n    }\n    return memoized;\n}\nfunction withErrorBoundary(component, errorBoundaryProps) {\n    const Wrapped = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ErrorBoundary, errorBoundaryProps, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(component, {\n            ...props,\n            ref\n        })));\n    // Format for display in DevTools\n    const name = component.displayName || component.name || \"Unknown\";\n    Wrapped.displayName = \"withErrorBoundary(\".concat(name, \")\");\n    return Wrapped;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZXJyb3ItYm91bmRhcnkvZGlzdC9yZWFjdC1lcnJvci1ib3VuZGFyeS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OzsySEFDMkc7QUFFM0csTUFBTU8scUNBQXVCUCxvREFBYUEsQ0FBQztBQUUzQyxNQUFNUSxlQUFlO0lBQ25CQyxVQUFVO0lBQ1ZDLE9BQU87QUFDVDtBQUNBLE1BQU1DLHNCQUFzQlYsNENBQVNBO0lBQ25DVyxZQUFZQyxLQUFLLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUcsSUFBSSxDQUFDQSxrQkFBa0IsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFDM0QsSUFBSSxDQUFDQyxLQUFLLEdBQUdSO0lBQ2Y7SUFDQSxPQUFPUyx5QkFBeUJQLEtBQUssRUFBRTtRQUNyQyxPQUFPO1lBQ0xELFVBQVU7WUFDVkM7UUFDRjtJQUNGO0lBQ0FJLHFCQUFxQjtRQUNuQixNQUFNLEVBQ0pKLEtBQUssRUFDTixHQUFHLElBQUksQ0FBQ00sS0FBSztRQUNkLElBQUlOLFVBQVUsTUFBTTtZQUNsQixJQUFJUSxxQkFBcUJDO1lBQ3pCLElBQUssSUFBSUMsT0FBT0MsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1KLE9BQU9LLE9BQU8sR0FBR0EsT0FBT0wsTUFBTUssT0FBUTtnQkFDdkZGLElBQUksQ0FBQ0UsS0FBSyxHQUFHSixTQUFTLENBQUNJLEtBQUs7WUFDOUI7WUFDQ1AsQ0FBQUEsc0JBQXNCLENBQUNDLGNBQWMsSUFBSSxDQUFDTixLQUFLLEVBQUVhLE9BQU8sTUFBTSxRQUFRUix3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CUyxJQUFJLENBQUNSLGFBQWE7Z0JBQ3JKSTtnQkFDQUssUUFBUTtZQUNWO1lBQ0EsSUFBSSxDQUFDQyxRQUFRLENBQUNyQjtRQUNoQjtJQUNGO0lBQ0FzQixrQkFBa0JwQixLQUFLLEVBQUVxQixJ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RCwyQkFBMkJHO0lBQzNCLE1BQU0sQ0FBQ2hELE9BQU9hLFNBQVMsR0FBR3pCLCtDQUFRQSxDQUFDO1FBQ2pDTSxPQUFPO1FBQ1B1RCxVQUFVO0lBQ1o7SUFDQSxNQUFNQyxXQUFXN0QsOENBQU9BOzhDQUFDLElBQU87Z0JBQzlCOEQsYUFBYTswREFBRTt3QkFDYkgsUUFBUWxELGtCQUFrQjt3QkFDMUJlLFNBQVM7NEJBQ1BuQixPQUFPOzRCQUNQdUQsVUFBVTt3QkFDWjtvQkFDRjs7Z0JBQ0FHLFlBQVk7MERBQUUxRCxDQUFBQSxRQUFTbUIsU0FBUzs0QkFDOUJuQjs0QkFDQXVELFVBQVU7d0JBQ1o7O1lBQ0Y7NkNBQUk7UUFBQ0QsUUFBUWxELGtCQUFrQjtLQUFDO0lBQ2hDLElBQUlFLE1BQU1pRCxRQUFRLEVBQUU7UUFDbEIsTUFBTWpELE1BQU1OLEtBQUs7SUFDbkI7SUFDQSxPQUFPd0Q7QUFDVDtBQUVBLFNBQVNHLGtCQUFrQkMsU0FBUyxFQUFFQyxrQkFBa0I7SUFDdEQsTUFBTUMsd0JBQVVsRSxpREFBVUEsQ0FBQyxDQUFDTyxPQUFPNEQsb0JBQVF2RSxvREFBYUEsQ0FBQ1MsZUFBZTRELGtDQUFvQnJFLG9EQUFhQSxDQUFDb0UsV0FBVztZQUNuSCxHQUFHekQsS0FBSztZQUNSNEQ7UUFDRjtJQUVBLGlDQUFpQztJQUNqQyxNQUFNQyxPQUFPSixVQUFVSyxXQUFXLElBQUlMLFVBQVVJLElBQUksSUFBSTtJQUN4REYsUUFBUUcsV0FBVyxHQUFHLHFCQUFxQkMsTUFBTSxDQUFDRixNQUFNO0lBQ3hELE9BQU9GO0FBQ1Q7QUFFb0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xccmF5YVxcU2hvcHBpbmdDYXJ0XFxwb3J0Zm9saW8gLSBDb3B5IC0gQ29weSAtIENvcHkgLSBDb3B5IC0gQ29weSAtIENvcHkgKDIpIC0gQ29weVxcbm9kZV9tb2R1bGVzXFxyZWFjdC1lcnJvci1ib3VuZGFyeVxcZGlzdFxccmVhY3QtZXJyb3ItYm91bmRhcnkuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlTWVtbywgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgRXJyb3JCb3VuZGFyeUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIGRpZENhdGNoOiBmYWxzZSxcbiAgZXJyb3I6IG51bGxcbn07XG5jbGFzcyBFcnJvckJvdW5kYXJ5IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5yZXNldEVycm9yQm91bmRhcnkgPSB0aGlzLnJlc2V0RXJyb3JCb3VuZGFyeS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBkaWRDYXRjaDogdHJ1ZSxcbiAgICAgIGVycm9yXG4gICAgfTtcbiAgfVxuICByZXNldEVycm9yQm91bmRhcnkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXJyb3JcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRvblJlc2V0LCBfdGhpcyRwcm9wcztcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgKF90aGlzJHByb3BzJG9uUmVzZXQgPSAoX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzKS5vblJlc2V0KSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyRvblJlc2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRvblJlc2V0LmNhbGwoX3RoaXMkcHJvcHMsIHtcbiAgICAgICAgYXJncyxcbiAgICAgICAgcmVhc29uOiBcImltcGVyYXRpdmUtYXBpXCJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnJvciwgaW5mbykge1xuICAgIHZhciBfdGhpcyRwcm9wcyRvbkVycm9yLCBfdGhpcyRwcm9wczI7XG4gICAgKF90aGlzJHByb3BzJG9uRXJyb3IgPSAoX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcykub25FcnJvcikgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMkb25FcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkb25FcnJvci5jYWxsKF90aGlzJHByb3BzMiwgZXJyb3IsIGluZm8pO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpZENhdGNoXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge1xuICAgICAgcmVzZXRLZXlzXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBUaGVyZSdzIGFuIGVkZ2UgY2FzZSB3aGVyZSBpZiB0aGUgdGhpbmcgdGhhdCB0cmlnZ2VyZWQgdGhlIGVycm9yIGhhcHBlbnMgdG8gKmFsc28qIGJlIGluIHRoZSByZXNldEtleXMgYXJyYXksXG4gICAgLy8gd2UnZCBlbmQgdXAgcmVzZXR0aW5nIHRoZSBlcnJvciBib3VuZGFyeSBpbW1lZGlhdGVseS5cbiAgICAvLyBUaGlzIHdvdWxkIGxpa2VseSB0cmlnZ2VyIGEgc2Vjb25kIGVycm9yIHRvIGJlIHRocm93bi5cbiAgICAvLyBTbyB3ZSBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGUgcmVzZXRLZXlzIG9uIHRoZSBmaXJzdCBjYWxsIG9mIGNEVSBhZnRlciB0aGUgZXJyb3IgaXMgc2V0LlxuXG4gICAgaWYgKGRpZENhdGNoICYmIHByZXZTdGF0ZS5lcnJvciAhPT0gbnVsbCAmJiBoYXNBcnJheUNoYW5nZWQocHJldlByb3BzLnJlc2V0S2V5cywgcmVzZXRLZXlzKSkge1xuICAgICAgdmFyIF90aGlzJHByb3BzJG9uUmVzZXQyLCBfdGhpcyRwcm9wczM7XG4gICAgICAoX3RoaXMkcHJvcHMkb25SZXNldDIgPSAoX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcykub25SZXNldCkgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMkb25SZXNldDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHByb3BzJG9uUmVzZXQyLmNhbGwoX3RoaXMkcHJvcHMzLCB7XG4gICAgICAgIG5leHQ6IHJlc2V0S2V5cyxcbiAgICAgICAgcHJldjogcHJldlByb3BzLnJlc2V0S2V5cyxcbiAgICAgICAgcmVhc29uOiBcImtleXNcIlxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIGZhbGxiYWNrUmVuZGVyLFxuICAgICAgRmFsbGJhY2tDb21wb25lbnQsXG4gICAgICBmYWxsYmFja1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRpZENhdGNoLFxuICAgICAgZXJyb3JcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgY2hpbGRUb1JlbmRlciA9IGNoaWxkcmVuO1xuICAgIGlmIChkaWRDYXRjaCkge1xuICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIGVycm9yLFxuICAgICAgICByZXNldEVycm9yQm91bmRhcnk6IHRoaXMucmVzZXRFcnJvckJvdW5kYXJ5XG4gICAgICB9O1xuICAgICAgaWYgKHR5cGVvZiBmYWxsYmFja1JlbmRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNoaWxkVG9SZW5kZXIgPSBmYWxsYmFja1JlbmRlcihwcm9wcyk7XG4gICAgICB9IGVsc2UgaWYgKEZhbGxiYWNrQ29tcG9uZW50KSB7XG4gICAgICAgIGNoaWxkVG9SZW5kZXIgPSBjcmVhdGVFbGVtZW50KEZhbGxiYWNrQ29tcG9uZW50LCBwcm9wcyk7XG4gICAgICB9IGVsc2UgaWYgKGZhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2hpbGRUb1JlbmRlciA9IGZhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJyZWFjdC1lcnJvci1ib3VuZGFyeSByZXF1aXJlcyBlaXRoZXIgYSBmYWxsYmFjaywgZmFsbGJhY2tSZW5kZXIsIG9yIEZhbGxiYWNrQ29tcG9uZW50IHByb3BcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnlDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBkaWRDYXRjaCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlc2V0RXJyb3JCb3VuZGFyeTogdGhpcy5yZXNldEVycm9yQm91bmRhcnlcbiAgICAgIH1cbiAgICB9LCBjaGlsZFRvUmVuZGVyKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzQXJyYXlDaGFuZ2VkKCkge1xuICBsZXQgYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIGxldCBiID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgcmV0dXJuIGEubGVuZ3RoICE9PSBiLmxlbmd0aCB8fCBhLnNvbWUoKGl0ZW0sIGluZGV4KSA9PiAhT2JqZWN0LmlzKGl0ZW0sIGJbaW5kZXhdKSk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVycm9yQm91bmRhcnlDb250ZXh0KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZS5kaWRDYXRjaCAhPT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIHZhbHVlLnJlc2V0RXJyb3JCb3VuZGFyeSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3JCb3VuZGFyeUNvbnRleHQgbm90IGZvdW5kXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUVycm9yQm91bmRhcnkoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEVycm9yQm91bmRhcnlDb250ZXh0KTtcbiAgYXNzZXJ0RXJyb3JCb3VuZGFyeUNvbnRleHQoY29udGV4dCk7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoe1xuICAgIGVycm9yOiBudWxsLFxuICAgIGhhc0Vycm9yOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgbWVtb2l6ZWQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcmVzZXRCb3VuZGFyeTogKCkgPT4ge1xuICAgICAgY29udGV4dC5yZXNldEVycm9yQm91bmRhcnkoKTtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGhhc0Vycm9yOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaG93Qm91bmRhcnk6IGVycm9yID0+IHNldFN0YXRlKHtcbiAgICAgIGVycm9yLFxuICAgICAgaGFzRXJyb3I6IHRydWVcbiAgICB9KVxuICB9KSwgW2NvbnRleHQucmVzZXRFcnJvckJvdW5kYXJ5XSk7XG4gIGlmIChzdGF0ZS5oYXNFcnJvcikge1xuICAgIHRocm93IHN0YXRlLmVycm9yO1xuICB9XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuZnVuY3Rpb24gd2l0aEVycm9yQm91bmRhcnkoY29tcG9uZW50LCBlcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgY29uc3QgV3JhcHBlZCA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IGNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeSwgZXJyb3JCb3VuZGFyeVByb3BzLCBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwge1xuICAgIC4uLnByb3BzLFxuICAgIHJlZlxuICB9KSkpO1xuXG4gIC8vIEZvcm1hdCBmb3IgZGlzcGxheSBpbiBEZXZUb29sc1xuICBjb25zdCBuYW1lID0gY29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudC5uYW1lIHx8IFwiVW5rbm93blwiO1xuICBXcmFwcGVkLmRpc3BsYXlOYW1lID0gXCJ3aXRoRXJyb3JCb3VuZGFyeShcIi5jb25jYXQobmFtZSwgXCIpXCIpO1xuICByZXR1cm4gV3JhcHBlZDtcbn1cblxuZXhwb3J0IHsgRXJyb3JCb3VuZGFyeSwgRXJyb3JCb3VuZGFyeUNvbnRleHQsIHVzZUVycm9yQm91bmRhcnksIHdpdGhFcnJvckJvdW5kYXJ5IH07XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsIkNvbXBvbmVudCIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VNZW1vIiwiZm9yd2FyZFJlZiIsIkVycm9yQm91bmRhcnlDb250ZXh0IiwiaW5pdGlhbFN0YXRlIiwiZGlkQ2F0Y2giLCJlcnJvciIsIkVycm9yQm91bmRhcnkiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwicmVzZXRFcnJvckJvdW5kYXJ5IiwiYmluZCIsInN0YXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiX3RoaXMkcHJvcHMkb25SZXNldCIsIl90aGlzJHByb3BzIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJvblJlc2V0IiwiY2FsbCIsInJlYXNvbiIsInNldFN0YXRlIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJpbmZvIiwiX3RoaXMkcHJvcHMkb25FcnJvciIsIl90aGlzJHByb3BzMiIsIm9uRXJyb3IiLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJwcmV2U3RhdGUiLCJyZXNldEtleXMiLCJoYXNBcnJheUNoYW5nZWQiLCJfdGhpcyRwcm9wcyRvblJlc2V0MiIsIl90aGlzJHByb3BzMyIsIm5leHQiLCJwcmV2IiwicmVuZGVyIiwiY2hpbGRyZW4iLCJmYWxsYmFja1JlbmRlciIsIkZhbGxiYWNrQ29tcG9uZW50IiwiZmFsbGJhY2siLCJjaGlsZFRvUmVuZGVyIiwidW5kZWZpbmVkIiwiY29uc29sZSIsIlByb3ZpZGVyIiwidmFsdWUiLCJhIiwiYiIsInNvbWUiLCJpdGVtIiwiaW5kZXgiLCJPYmplY3QiLCJpcyIsImFzc2VydEVycm9yQm91bmRhcnlDb250ZXh0IiwiRXJyb3IiLCJ1c2VFcnJvckJvdW5kYXJ5IiwiY29udGV4dCIsImhhc0Vycm9yIiwibWVtb2l6ZWQiLCJyZXNldEJvdW5kYXJ5Iiwic2hvd0JvdW5kYXJ5Iiwid2l0aEVycm9yQm91bmRhcnkiLCJjb21wb25lbnQiLCJlcnJvckJvdW5kYXJ5UHJvcHMiLCJXcmFwcGVkIiwicmVmIiwibmFtZSIsImRpc3BsYXlOYW1lIiwiY29uY2F0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-error-boundary/dist/react-error-boundary.development.js\n");

/***/ })

};
;